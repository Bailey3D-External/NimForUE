# tooling for NimForUE

import std / [os, osproc, parseopt, tables, strformat, strutils, times, sequtils]
import buildscripts / [nimforueconfig, copylib, nimcachebuild]

var options: Table[string, string]

type Task = object
  name: string
  description: string
  routine: proc(options: Table[string, string]) {.nimcall.}

var tasks: seq[tuple[name:string, t:Task]]

template task(taskName: untyped, desc: string, body: untyped): untyped =
  proc `taskName`(options: Table[string, string]) {.nimcall.} =
    let start = now()
    echo ">>>> Task: ", astToStr(taskName), " <<<<"
    body
    echo "!!>> ", astToStr(taskName), " Time: ", $(now() - start), " <<<<"
  tasks.add (name:astToStr(taskName), t:Task(name: astToStr(taskName), description: desc, routine: `taskName`))


proc generateFFIGenFile*() = 
  let genFilePath = getNimForUEConfig().genFilePath
  let content = fmt"""

#AUTOGENERATED FILE. DO NOT EDIT.

import locks
import std/dynlib
import hostbase


"""
  # if nnot fileExists(genFilePath):
    
  writeFile(genFilePath, content)


proc echoTasks() =
  echo "Here are the task available: "
  for t in tasks:
    echo "  ", t.name, if t.name.len < 6: "\t\t" else: "\t", t.t.description

proc main() =
  var params = commandLineParams().join(" ")
  if params.len == 0:
    echo "nue: NimForUE tool"
    echoTasks()

  var p = initOptParser()
  for kind, key, val in p.getopt():
    case kind
    of cmdEnd: doAssert(false) # cannot happen with getopt
    of cmdShortOption, cmdLongOption:
      case key:
      of "h", "help":
        echo "Usage, Commands and Options for nue"
        echoTasks()
        quit()
      else:
        options[key] = val
    of cmdArgument:
      var ts = tasks.filterIt(it.name == key)
      if ts.len == 1:
        ts[0].t.routine(options)
      else:
        echo &"!! Unknown task {key}."
        echoTasks()

# --- Define Tasks ---

let watchInterval = 500

task watch, "Monitors the components folder for changes to recompile.":
  proc ctrlc() {.noconv.} =
    echo "Ending watcher"
    quit()

  setControlCHook(ctrlc)

  let updateCmd =
    when defined windows:
      ("nue.exe", ["guestpch"])
    elif defined macosx:
      ("/bin/zsh", ["nueMac.sh"])

  let srcDir = getCurrentDir() / "src/nimforue/"
  echo &"Monitoring components for changes in \"{srcDir}\".  Ctrl+C to stop"
  var lastTimes = newTable[string, Time]()
  for path in walkDirRec(srcDir ):
    if not path.endsWith(".nim"):
      continue
    lastTimes[path] = getLastModificationTime(path)

  while true:
    for path in walkDirRec(srcDir ):
      if not path.endsWith(".nim"):
        continue
      var lastTime = getLastModificationTime(path)
      if path notin lastTimes:
        lastTimes[path] = Time() 
        
      if lastTime > lastTimes[path]:
        lastTimes[path] = lastTime
        echo &"-- Recompiling {path} --"
        let p = startProcess(updateCmd[0], getCurrentDir(), updateCmd[1])

        for line in p.lines:
          echo line
        p.close

        echo &"-- Finished Recompiling {path} --"

    sleep watchInterval

task w, "Alias for watch":
  watch(options)

task guest, "Builds the main lib. The one that makes sense to hot reload.":
    generateFFIGenFile()
    discard execCmd("nim cpp --app:lib --nomain --d:genffi -d:withue -d:withPCH --nimcache:.nimcache/guest src/nimforue.nim")
    copyNimForUELibToUEDir()

task guestpch, "Builds the hot reloading lib. Options -f to force rebuild, --nogen to compile from nimcache cpp sources without generating.":
    generateFFIGenFile()

    var force = ""
    if "f" in options:
      force = "-f"
    
    var noGen = "nogen" in options

    if not noGen:
      discard execCmd(&"nim cpp {force} -g --stacktrace:on --genscript --app:lib --nomain --d:genffi -d:withue -d:withPCH --nimcache:.nimcache/guestpch src/nimforue.nim")

    if nimcacheBuild() == Success:
      copyNimForUELibToUEDir()

task g, "Alias to guestpch":
  guestpch(options)

task winpch, "For Windows, Builds the pch file for Unreal Engine via nim":
  winpch()

# --- End Tasks ---

main()