# tooling for NimForUE
echo "test"
#[
import std / [os, osproc, parseopt, tables, strformat, strutils, times, sequtils, options, terminal, sugar]
import buildscripts / [nimforueconfig, nimcachebuild, buildscripts]

var taskOptions: Table[string, string]
let config = getNimForUEConfig()

type Task = object
  name: string
  description: string
  routine: proc(taskOptions: Table[string, string]) {.nimcall.}

var tasks: seq[tuple[name:string, t:Task]]

template task(taskName: untyped, desc: string, body: untyped): untyped =
  proc `taskName`(taskOptions: Table[string, string]) {.nimcall.} =
    let start = now()
    log ">>>> Task: " & astToStr(taskName) & " <<<<"
    body
    log "!!>> " & astToStr(taskName) & " Time: " & $(now() - start) & " <<<<"
  tasks.add (name:astToStr(taskName), t:Task(name: astToStr(taskName), description: desc, routine: `taskName`))


proc generateFFIGenFile*() = 
  #makes sure FFI gen file exists (not tracked) so it can be imported from hostnimforue but only if it doesnt exists so it doesnt override its content
  if fileExists(config.genFilePath):
    return
  let content = fmt"""

#AUTOGENERATED FILE. DO NOT EDIT.

import locks
import std/dynlib
import hostbase


"""
  writeFile(config.genFilePath, content)


proc echoTasks() =
  log "Here are the task available: "
  for t in tasks:
    log("  " & t.name & (if t.name.len < 6: "\t\t" else: "\t") & t.t.description)

proc main() =
  if commandLineParams().join(" ").len == 0:
    log "nue: NimForUE tool"
    echoTasks()

  var p = initOptParser()
  var ts:Option[Task]
  var args: string
  for kind, key, val in p.getopt():
    case kind
    of cmdEnd: doAssert(false) # cannot happen with getopt
    of cmdShortOption, cmdLongOption:
      case key:
      of "h", "help":
        log "Usage, Commands and Options for nue"
        echoTasks()
        quit()
      else:
        taskOptions[key] = val
    of cmdArgument:
      let res = tasks.filterIt(it.name == key) #TODO: Match first characters if whole word doesn't match, so we don't need task aliases
      if res.len > 0:
        ts = some(res[0].t)
      elif ts.isSome():
        doAssert(not taskOptions.hasKey("args"), "TODO: accept more than one task argument")
        taskOptions["args"] = key
      else:
        log &"!! Unknown task {key}."
        echoTasks()

  if ts.isSome():
    ts.get().routine(taskOptions)


# --- Define Tasks ---

let watchInterval = 500

task watch, "Monitors the components folder for changes to recompile.":
  proc ctrlc() {.noconv.} =
    log "Ending watcher"
    quit()

  setControlCHook(ctrlc)

  let updateCmd =
    when defined windows:
      ("nue.exe", ["guestpch"])
    elif defined macosx:
      ("/bin/zsh", ["nueMac.sh"])

  let srcDir = getCurrentDir() / "src/nimforue/"
  log &"Monitoring components for changes in \"{srcDir}\".  Ctrl+C to stop"
  var lastTimes = newTable[string, Time]()
  for path in walkDirRec(srcDir ):
    if not path.endsWith(".nim"):
      continue
    lastTimes[path] = getLastModificationTime(path)

  while true:
    for path in walkDirRec(srcDir ):
      if not path.endsWith(".nim"):
        continue
      var lastTime = getLastModificationTime(path)
      if path notin lastTimes:
        lastTimes[path] = Time() 
        
      if lastTime > lastTimes[path]:
        lastTimes[path] = lastTime
        log(&"-- Recompiling {path} --")
        let p = startProcess(updateCmd[0], getCurrentDir(), updateCmd[1])

        for line in p.lines:
          if line.contains("Error:") or line.contains("fatal error") or line.contains("error C"):
            log(line, lgError)
          else:
            log(line)
        p.close

        log(&"-- Finished Recompiling {path} --")

    sleep watchInterval

task w, "Alias for watch":
  watch(taskOptions)

task guest, "Builds the main lib. The one that makes sense to hot reload.":
    generateFFIGenFile()
    doAssert(execCmd("nim cpp --app:lib --nomain --d:genffi -d:withue -d:withPCH --nimcache:.nimcache/guest src/nimforue.nim") == 0)
    copyNimForUELibToUEDir()

task guestpch, "Builds the hot reloading lib. Options -f to force rebuild, --nogen to compile from nimcache cpp sources without generating, --nolinedir turns off #line directives in cpp output.":
    generateFFIGenFile()

    var force = ""
    if "f" in taskOptions:
      force = "-f"
    var noGen = "nogen" in taskOptions
    var lineDir = if "nolinedir" in taskOptions: "off" else: "on"

    if not noGen:
      doAssert(execCmd(&"nim cpp {force} -g --lineDir:{lineDir} --stacktrace:on --genscript --app:lib --nomain --d:genffi -d:withue -d:withPCH --nimcache:.nimcache/guestpch src/nimforue.nim") == 0)

    if nimcacheBuild() == Success:
      copyNimForUELibToUEDir()

task g, "Alias to guestpch":
  guestpch(taskOptions)

task winpch, "For Windows, Builds the pch file for Unreal Engine via nim":
  winpch()

task pp, "Preprocess a file with MSVC":
  if "args" in taskOptions:
    preprocess(taskOptions["args"])
  else:
    quit("Usage: nue.exe pp relative_filepath\n\tThe filepath should be relative and the base directory and its sub-directories will be included for the compiler.\n\tExample: nue pp ./Source/NimForUE/Private/TestActor.cpp\n\tThe ./Source directory and its subdirectories will be included for preprocessing.")

task host, "Builds the host that's hooked to unreal":
  generateFFIGenFile()
  doAssert(execCmd("nim cpp --app:lib --nomain --d:host --nimcache:.nimcache/host src/hostnimforue/hostnimforue.nim") == 0)
  # copy header
  let ffiHeaderSrc = ".nimcache/host/NimForUEFFI.h"
  let ffiHeaderDest = "NimHeaders/NimForUEFFI.h"
  copyFile(ffiHeaderSrc, ffiHeaderDest)
  log("Copied " & ffiHeaderSrc & " to " & ffiHeaderDest)

  # copy lib
  let libDir = "./Binaries/nim"
  let libDirUE = libDir / "ue"
  createDir(libDirUE)

  let hostLibName = "hostnimforue"
  let baseFullLibName = getFullLibName(hostLibName)
  let fileFullSrc = libDir/baseFullLibName
  let fileFullDst = libDirUE/baseFullLibName

  try:
    copyFile(fileFullSrc, fileFullDst)
  except OSError as e:
    when defined windows: # This will fail on windows if the host dll is in use.
      quit("Error copying to " & fileFullDst & ". " & e.msg, QuitFailure)

  log("Copied " & fileFullSrc & " to " & fileFullDst)

  when defined windows:
    let weakSymbolsLib = hostLibName & ".lib"
    copyFile(libDir/weakSymbolsLib, libDirUE/weakSymbolsLib)
  elif defined macosx: #needed for dllimport in ubt mac only
    let dst = "/usr/local/lib" / baseFullLibName
    copyFile(fileFullSrc, dst)
    log("Copied " & fileFullSrc & " to " & dst)

task h, "Alias to host":
  host(taskOptions)


task cleanh, "Clean the .nimcache/host folder":
  removeDir(".nimcache/host")

task cleang, "Clean the .nimcache guestpch and winpch folder":
  removeDir(".nimcache/winpch")
  removeDir(".nimcache/guestpch")

task clean, "Clean the nimcache folder":
  cleanh(taskOptions)
  cleang(taskOptions)

task ubuild, "Calls Unreal Build Tool for your project":
  let curDir = getCurrentDir()
  let walkPattern = config.pluginDir & "/../../*.uproject"
  try:
    let uprojectFile = walkPattern.walkFiles.toSeq[0]
    setCurrentDir(config.engineDir)
    let buildCmd = r"Build\BatchFiles\" & (
      case config.targetPlatform
        of Win64: "Build.bat"
        of Mac: r"BatchFiles\Mac\Build.sh" # untested
      )

    doAssert(execCmd(buildCmd & " NimForUEDemoEditor " &
      $config.targetPlatform & " " &
      $config.targetConfiguration & " " &
      uprojectFile & " -waitmutex") == 0)
    setCurrentDir(curDir)
  except:
    log("Could not find uproject here: " & walkPattern & "\n", lgError)
    quit(QuitFailure)

task rebuild, "Cleans and rebuilds the host and guest":
  clean(taskOptions)
  host(taskOptions)
  ubuild(taskOptions)
  guestpch(taskOptions)

task dumpConfig, "Displays the config variables":
  dump config

# --- End Tasks ---

main()
]#