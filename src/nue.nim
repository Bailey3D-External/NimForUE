# tooling for NimForUE

import std / [os, osproc, parseopt, tables, strformat, strutils, times, sequtils, options, terminal]
import buildscripts / [nimforueconfig, copylib, nimcachebuild]

var taskOptions: Table[string, string]

type Task = object
  name: string
  description: string
  routine: proc(taskOptions: Table[string, string]) {.nimcall.}

var tasks: seq[tuple[name:string, t:Task]]

template task(taskName: untyped, desc: string, body: untyped): untyped =
  proc `taskName`(taskOptions: Table[string, string]) {.nimcall.} =
    let start = now()
    echo ">>>> Task: ", astToStr(taskName), " <<<<"
    body
    echo "!!>> ", astToStr(taskName), " Time: ", $(now() - start), " <<<<"
  tasks.add (name:astToStr(taskName), t:Task(name: astToStr(taskName), description: desc, routine: `taskName`))


proc generateFFIGenFile*() = 
  let genFilePath = getNimForUEConfig().genFilePath
  let content = fmt"""

#AUTOGENERATED FILE. DO NOT EDIT.

import locks
import std/dynlib
import hostbase


"""
  # if nnot fileExists(genFilePath):
    
  writeFile(genFilePath, content)



#TODO this file contains repetition that can be error prone. Needs to be cleaned up and unify with the mac way of doing things


type LogLevel* = enum 
    lgNone
    lgInfo
    lgDebug 
    lgWarning
    lgError

proc log*(msg:string, level=lgInfo) = 

  # stdout.setBackGroundColor(bg8Bit, true)
    #Change it base on the level
    let fgColor = case level 
            of lgNone: fgWhite
            of lgInfo: fgBlue
            of lgDebug: fgMagenta
            of lgWarning: fgYellow
            of lgError: fgRed

    stdout.setForegroundColor(fgColor)
    echo msg
    stdout.resetAttributes()


proc echoTasks() =
  echo "Here are the task available: "
  for t in tasks:
    echo "  ", t.name, if t.name.len < 6: "\t\t" else: "\t", t.t.description

proc main() =
  if commandLineParams().join(" ").len == 0:
    echo "nue: NimForUE tool"
    echoTasks()

  var p = initOptParser()
  var ts:Option[Task]
  var args: string
  for kind, key, val in p.getopt():
    case kind
    of cmdEnd: doAssert(false) # cannot happen with getopt
    of cmdShortOption, cmdLongOption:
      case key:
      of "h", "help":
        echo "Usage, Commands and Options for nue"
        echoTasks()
        quit()
      else:
        taskOptions[key] = val
    of cmdArgument:
      let res = tasks.filterIt(it.name == key)
      if res.len > 0:
        ts = some(res[0].t)
      elif ts.isSome():
        doAssert(not taskOptions.hasKey("args"), "TODO: accept more than one task argument")
        taskOptions["args"] = key
      else:
        echo &"!! Unknown task {key}."
        echoTasks()

  if ts.isSome():
    ts.get().routine(taskOptions)

# --- Define Tasks ---

let watchInterval = 500

task watch, "Monitors the components folder for changes to recompile.":
  proc ctrlc() {.noconv.} =
    echo "Ending watcher"
    quit()

  setControlCHook(ctrlc)

  let updateCmd =
    when defined windows:
      ("nue.exe", ["guestpch"])
    elif defined macosx:
      ("/bin/zsh", ["nueMac.sh"])

  let srcDir = getCurrentDir() / "src/nimforue/"
  echo &"Monitoring components for changes in \"{srcDir}\".  Ctrl+C to stop"
  var lastTimes = newTable[string, Time]()
  for path in walkDirRec(srcDir ):
    if not path.endsWith(".nim"):
      continue
    lastTimes[path] = getLastModificationTime(path)

  while true:
    for path in walkDirRec(srcDir ):
      if not path.endsWith(".nim"):
        continue
      var lastTime = getLastModificationTime(path)
      if path notin lastTimes:
        lastTimes[path] = Time() 
        
      if lastTime > lastTimes[path]:
        lastTimes[path] = lastTime
        log(&"-- Recompiling {path} --")
        let p = startProcess(updateCmd[0], getCurrentDir(), updateCmd[1])

        for line in p.lines:
          if line.contains("Error:") or line.contains("fatal error"):
            log(line, lgError)
          else:
            echo line
        p.close

        log(&"-- Finished Recompiling {path} --")

    sleep watchInterval

task w, "Alias for watch":
  watch(taskOptions)

task guest, "Builds the main lib. The one that makes sense to hot reload.":
    generateFFIGenFile()
    discard execCmd("nim cpp --app:lib --nomain --d:genffi -d:withue -d:withPCH --nimcache:.nimcache/guest src/nimforue.nim")
    copyNimForUELibToUEDir()

task guestpch, "Builds the hot reloading lib. Options -f to force rebuild, --nogen to compile from nimcache cpp sources without generating.":
    generateFFIGenFile()

    var force = ""
    if "f" in taskOptions:
      force = "-f"
    
    var noGen = "nogen" in taskOptions

    if not noGen:
      discard execCmd(&"nim cpp {force} -g --stacktrace:on --genscript --app:lib --nomain --d:genffi -d:withue -d:withPCH --nimcache:.nimcache/guestpch src/nimforue.nim")

    if nimcacheBuild() == Success:
      copyNimForUELibToUEDir()

task g, "Alias to guestpch":
  guestpch(taskOptions)

task winpch, "For Windows, Builds the pch file for Unreal Engine via nim":
  winpch()

task pp, "Preprocess a file with MSVC":
  if "args" in taskOptions:
    preprocess(taskOptions["args"])
  else:
    quit("Usage: nue.exe pp filepath")


# --- End Tasks ---

main()